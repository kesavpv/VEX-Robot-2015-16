#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  LED,            sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           rightBack,     tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           rightFront,    tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           intakeHigh,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           RightDrive,    tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port6,           LeftDrive,     tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port7,           intakeLow,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftBack,      tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           leftFront,     tmotorVex393HighSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define DESIRED_RPM_MOTOR 107
#define DESIRED_RPM_FLYWHEEL 1928

#define kP	0.02
#define kI	0.04

float RPM_Right_Motor;
float RPM_Left_Motor;

float RPM_Right_FlyWheel;
float RPM_Left_FlyWheel;

float speed_Right = 0;
float speed_Left = 0;

task main()
{
	float pidError_Right = 0;
	float pidIntegral_Right = 0;
	float pidValue_Right;

	float pidError_Left = 0;
	float pidIntegral_Left = 0;
	float pidValue_Left;

//	float fast = 120,
//	float med = 90,
//	float slow = 65;
//	float low = 50;

	resetMotorEncoder(leftBack);
	resetMotorEncoder(rightBack);

	//clearLCDLine(0);
	//displayLCDCenteredString(0, "Motor   FlyWheel");

	while(true)
	{
		RPM_Right_Motor = getMotorVelocity(rightBack);
		RPM_Right_FlyWheel = RPM_Right_Motor * 18;

		RPM_Left_Motor = getMotorVelocity(leftBack);
		RPM_Left_FlyWheel = RPM_Left_Motor * 18;

		pidError_Right = DESIRED_RPM_FLYWHEEL - RPM_Right_FlyWheel;
		pidError_Left = DESIRED_RPM_FLYWHEEL - RPM_Left_FlyWheel;

		if(pidError_Right < 50)
			pidIntegral_Right += pidError_Right;
		else
			pidIntegral_Right = 0;

		if(pidError_Left < 50)
			pidIntegral_Left += pidError_Left;
		else
			pidIntegral_Left = 0;

		pidValue_Right = (kP * pidError_Right) + (kI * pidIntegral_Right);
		speed_Right += pidValue_Right;

		pidValue_Left = (kP * pidError_Left) + (kI * pidIntegral_Left);
		speed_Left += pidValue_Left;

		if(speed_Right > 127)
			speed_Right = 127;
		else if(speed_Right < -127)
			speed_Right = -127;

		if(speed_Left > 127)
			speed_Left = 127;
		else if(speed_Left < -127)
			speed_Left = -127;

//		motor[intakeLow] = 127;
//		motor[intakeHigh] = 127;

		motor[rightFront]   = speed_Right;
		motor[rightBack] = speed_Right;

		motor[leftFront]   = speed_Left;
		motor[leftBack] = speed_Left;

		SensorValue[LED] = RPM_Right_FlyWheel > DESIRED_RPM_FLYWHEEL && RPM_Left_FlyWheel > DESIRED_RPM_FLYWHEEL;

//		clearLCDLine(1);
//		displayLCDNumber(1, 0, RPM_Right);
//		displayLCDNumber(1, 8, RPM_Right_FlyWheel);
	}
}
